# Lab 4 helper functions
# This skeleton does not handle race conditions/locks

# ------------------------------------------------------------------------------
# Start listening and handle incoming connections in board() function
# ------------------------------------------------------------------------------
def start_board():
  ip = mycontext['ip']
  port = mycontext['port']
  print "Listening on IP " + str(ip) +" port " + str(port)
  try:
    listencommhandle = waitforconn(ip,port,board)
  except Exception, e:
    print "Exception in start_board: %s, %s\n" %(type(e), e)
    #pass

# ------------------------------------------------------------------------------
# Called when an incoming message is received.
# ------------------------------------------------------------------------------
def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  try:
    msgheader = sockobj.recv(1024) # Receive message
    # React depending on message type: HTTP GET or POST, or some other type of communication.
    if msgheader.startswith( 'GET' ):

      #Try to delete message from history
      msgsToDelete = mycontext['changeHistory']
      if len(msgsToDelete) > 0:
        for msg in msgsToDelete:
          delete_msg_from_board(msg[0], msg[1])
          mycontext['changeHistory'].remove(msg)

      handle_request_get(msgheader, sockobj, thiscommhandle)

    elif msgheader.startswith( 'POST /Add' ):
      print 'DEBUG: POST /Add'
      handle_request_add(msgheader, sockobj, thiscommhandle, "POST")
      post_msg_to_all_boards()

    elif msgheader.startswith( 'POST /Change' ):
      handle_request_change(msgheader, sockobj, thiscommhandle, "POST")

    #Handle a posting vessels new message
    elif msgheader.startswith( 'BOARD_UPDATE /Add'):
      print 'DEBUG: BOARD_UPDATE /Add'
      handle_request_add(msgheader,sockobj, thiscommhandle, "BOARD_UPDATE")

    #Handle a posting vessels deleted message
    elif msgheader.startswith( 'BOARD_UPDATE /Change'):
      handle_request_change(msgheader, sockobj, thiscommhandle, "BOARD_UPDATE")

  except Exception, e:
    print "Exception in board: %s, %s\n" %(type(e), e)

# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def handle_request_get(msgheader, sockobj, thiscommhandle):
  print 'DEBUG: handle_request_get'
  htmlresponse = generate_html_page("")
  sockobj.send(make_http_ok_response(htmlresponse))
  stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Handles POST \Add request from browser
# ------------------------------------------------------------------------------
def handle_request_add(msgheader, sockobj, thiscommhandle, request):

  # Increment logical clock
  mycontext['timeStamp'] = mycontext['timeStamp'] + 1

  # Check if request is a new POST or if it is an UPDATE from another board
  # If POST from this node

  if request == "POST":
    print 'DEBUG: POST case in handle_request_add'
    comment = msgheader.split('comment=')[1]
    entry = "comment=%s&timeStamp=%u&ip=%s&port=%u&action=%s" % (comment, mycontext['timeStamp'], mycontext['ip'], mycontext['port'], 'Add')

    # Insert formatted entry in dict
    print 'DEBUG entries dict:', mycontext['entries']
    mycontext['entries'][mycontext['timeStamp']] = (mycontext['ip'], entry)

  # If msg from other node
  elif request == 'BOARD_UPDATE':
    entriesList = mycontext['entries']

    # Returns list of entries
    entries = msgheader.split('entries=')[1].split('||')

    # len -1 to ignore everything after last '||'
    nbrOfEntries = range(len(entries)-1)

    # TODO: More intuitive to sort later?
    nbrOfEntries.sort(reverse=True)

    # Get timestamp and IP to check collisions and sort
    for entry in nbrOfEntries:
      fullEntry = entries[entry]
      parameters = extract_parameters_from_query(fullEntry)

      entryTimeStamp = int(parameters['timeStamp'])
      entryIP = parameters['ip']

      # If dict key collision, append to collision list and sort
      if entryTimeStamp in entriesList:
        entriesList[entryTimeStamp].append((entryIP, fullEntry))
        entriesList[entryTimeStamp].sort(cmp=compareIPaddresses, key=getKey)
      # If no collision, insert in dict
      else:
        entriesList[entryTimeStamp] = [(entryIP, fullEntry)]

    # Update global entries list
    mycontext['entries'] = entriesList

  # Send the page
  handle_request_get(msgheader, sockobj, thiscommhandle)

#Update rest of the board of the new message
def post_msg_to_all_boards():
  print 'DEBUG: post_msg_to_all_boards'
  msg = 'BOARD_UPDATE /Add' + 'entries='
  for entry in mycontext['entries']:
    print "Appending to msg string:", entry
    msg += entry[2] + '||'

  vesselIPs = mycontext['iplist']
  for ipaddr in vesselIPs:
    socketobject = openconn(ipaddr, mycontext['port'])
    socketobject.send(msg)
    socketobject.close()

#Update rest of the board of the deleted message
def update_msg_to_all_boards(deletedMsg):
  msg = 'BOARD_UPDATE /Change' + 'change=' + deletedMsg

  vesselIPs = mycontext['iplist']
  for ipaddr in vesselIPs:
    socketobject = openconn(ipaddr, mycontext['port'])
    socketobject.send(msg)
    socketobject.close()

#Deletes the message from the local board
#Returns -1 if the delete request arrives before the actual message
def delete_msg_from_board(timeStamp, ip):
  entrieslist = mycontext['entries']

  for entryIndex in range(len(entrieslist)):
    entry = extract_parameters_from_query(entrieslist[entryIndex][2])
    if timeStamp == int(entry['timeStamp']) and ip == entry['ip']:
      return mycontext['entries'].pop(entryIndex)

  mycontext['changeHistory'].append = (timeStamp, ip)
  return -1

# ------------------------------------------------------------------------------
# Handles POST /Change request from browser
# ------------------------------------------------------------------------------
def handle_request_change(msgheader, sockobj, thiscommhandle, request):
  if request == "BOARD_UPDATE":

    msgheader = msgheader.split("change=")[1]
    msg = extract_parameters_from_query(msgheader)
    deletedMsg = delete_msg_from_board(int(msg['timeStamp']), msg['ip'])

    handle_request_get(msgheader, sockobj, thiscommhandle)

  else:
    #extract the query from the HTTP request
    query = extract_http_request_contents(msgheader)
    # extract the query parameters
    parameters = extract_parameters_from_query(query)
    #comment = parameters['comment']
    action = parameters['action']
    ref_timeStamp = int(parameters['timeStamp'])
    ref_ip = parameters['ip']
    #ref_port = int(parameters['port'])

    if action == "Delete":
      deletedMsg = delete_msg_from_board(ref_timeStamp, ref_ip)

    #Send the page
    handle_request_get(msgheader, sockobj, thiscommhandle)
    #update all other boards of the deleted message
    update_msg_to_all_boards(deletedMsg[2])

# Compares two IP addresses
def compareIPaddresses(ip1, ip2):
  ip1int = ipToInt(ip1)
  ip2int = ipToInt(ip2)

  if ip1int == ip2int:
    return 0
  elif ip1int > ip2int:
    return 1
  else:
    return -1

# Helper function to convert IP to int
def ipToInt(ipaddr):
  ipInt = ''
  for octet in ipaddr.split('.'):
    ipInt += octet
  return long(ipInt)

# "key" function for sort()
def getKey(msgTuple):
  return msgTuple[0]

# ------------------------------------------------------------------------------
# Wrap into HTTP headers
# ------------------------------------------------------------------------------
def make_http_ok_response(htmlresponse):
    return "HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
    "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse)

# ------------------------------------------------------------------------------
# Utility function to extract the contents (payload) from HTTP request
# ------------------------------------------------------------------------------
def extract_http_request_contents(header):
  # find content length
  content_length = header.split('Content-Length: ')[1]
  content_length = int(content_length.split('\r\n')[0])

  # extract the http response body and discard the header
  contetns = header[-content_length:]
  return contetns

# ------------------------------------------------------------------------------
# Utility function to extract query parameter from HTML query
# ------------------------------------------------------------------------------
def extract_parameters_from_query(msg):
  # extract the query parameters as a dictionary: {name:value}
  # example input format: comment=aa&timeStamp=2&ip=127.0.0.1&port=63101&action=Delete
  parameters={}
  arr = msg.split('&')
  for a in arr:
    pp = a.split('=')
    if len(pp)>1:
      parameters[pp[0]] = pp[1]
  return parameters

# ------------------------------------------------------------------------------
# Utility function to wrap an entry with HTML form markup
# ------------------------------------------------------------------------------
def entry_to_html(entry):
  if len(entry) > 0:
    # extract the query parameters
    parameters = extract_parameters_from_query(entry)
    comment = parameters['comment']
    action = parameters['action']
    src_ts = int(parameters['timeStamp'])
    src_ip = parameters['ip']
    src_port = int(parameters['port'])

    if action == 'Add':
      return '''<form class="entry" method="post" action="Change" >
                  <input type="text" name="comment" value="%s" size="50"/>
                  <input type="text" name="timeStamp" value="%u" />
                  <input type="text" name="ip" value="%s" />
                  <input type="hidden" name="port" value="%u" />
                  <input type="submit" name="action" value="Modify" />
                  <input type="submit" name="action" value="Delete" />
                </form>''' %(comment, src_ts, src_ip, src_port)
  return ""

# ------------------------------------------------------------------------------
# Outputs the blackboard html
# Optional parameter: status.
# ------------------------------------------------------------------------------
def generate_html_page(status=""):
  print 'DEBUG: generate_html_page'
  #Initialize blackboard content

  # dynamic title showing Ip address, port and up time.
  board_title = '<div id="boardtitle_placeholder" class="boardtitle">Board contents at host: %s:%u, up time: %u sec.</div>' %(mycontext['ip'], mycontext['port'], int(getruntime()))
  # An optional status message
  status_message = "<div class='status'>%s</div>" % (status)

  # convert entries to html
  #entries = [entry_to_html(entry[2]) for entry in mycontext['entries']]
  entriesKeys = mycontext['entries'].keys()
  print 'Entries keys list:', entriesKeys
  entriesKeys.sort()

  entries = []
  for key in mycontext['entries']:
    for entry in mycontext['entries'][key]
    entries.append(entry[2])

  entries = ''.join(entries)

  # merging the contents of the board with the title
  # and wrapping all with <div id="boardcontents_placeholderâ€>...</div>
  content = [mycontext['headerhtml'], '<div id="boardcontents_placeholder">', board_title, status_message, entries, '</div>', mycontext['footerhtml']]

  #Concatenate strings into huge string representing the final html
  content = "".join(content)
  del entries
  return content

# ------------------------------------------------------------------------------
# Main entry point of the program. Initalizes global variables in mycontext
# and calls start_board() which opens the socket for incoming connections.
# ------------------------------------------------------------------------------
if callfunc == 'initialize':
  # Running remotely (assuming that we pass one input argument only when we run remotely):
  # whenever this vessel gets a connection on its IPaddress:Clearinghouseport it'll call function board
  if len(callargs) == 1:
    port = int(callargs[0])
    ip = getmyip()

    vesselIPs = []
    ipList = open('iplist.txt', 'r')
    for ipaddr in ipList:
      ipaddr = ipaddr.rstrip()
      if not ipaddr == ip:
        vesselIPs.append(ipaddr)

    mycontext['iplist'] = vesselIPs
    ipList.close()

  # To run locally: use the loopback ip address (127.0.0.1) and a port in the range 63100 .. 63110
  # If you start multiple local instances using different ports, you can debug and test your code locally
  # example:
  # python ../demokit/repy.py ../demokit/restrictions.default skeleton2015advanced.repy 127.0.0.1 63100
  elif len(callargs) == 2:
    port = int(callargs[1])
    ip = callargs[0]

  # Fail if we don't have 1 or 2 arguments
  else:
    raise Exception("Specify a port only for auto detection of IP, or specify IP and port")

  #GLOBAL Variables go to mycontext

  #logical clock\timestamp
  mycontext['timeStamp'] = 0
  mycontext['lock'] = getlock()

  #Initialize Port and IP
  mycontext['port'] = port
  mycontext['ip'] = ip

  #read header and footer html files
  mycontext['headerhtml'] = file("header.html").read()
  mycontext['footerhtml'] = file("footer.html").read()

  #Initialize entrieslist to hold future board entries
  mycontext['entries'] = {}
  #Keep track of delete history if the delete request arrives before the message
  mycontext['changeHistory'] = []

  start_board()
