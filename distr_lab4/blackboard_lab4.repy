# Lab 4 helper functions
# This skeleton does not handle race conditions/locks

# ------------------------------------------------------------------------------
# Start listening and handle incoming connections in board() function
# ------------------------------------------------------------------------------
def start_board():
  ip = mycontext['ip']
  port = mycontext['port']
  print "Listening on IP " + str(ip) +" port " + str(port)
  try:
    listencommhandle = waitforconn(ip,port,board)
  except Exception, e:
    print "Exception in start_board: %s, %s\n" %(type(e), e)
    raise
    #pass

# ------------------------------------------------------------------------------
# Called when an incoming message is received.
# ------------------------------------------------------------------------------
def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  try:
    msgheader = sockobj.recv(1024) # Receive message

    # React depending on message type: HTTP GET or POST, or some other type of communication.
    if msgheader.startswith( 'GET' ):
      handle_request_get(sockobj, thiscommhandle)
    elif msgheader.startswith( 'POST /Add' ):
      handle_request_add(msgheader, sockobj, thiscommhandle)
    elif msgheader.startswith( 'POST /Change' ):
      handle_request_change(msgheader, sockobj, thiscommhandle)
    elif msgheader.startswith( 'BOARD_UPDATE' ):
      handle_update(msgheader, sockobj, thiscommhandle)

  except Exception, e:
    print "Exception in board: %s, %s\n" %(type(e), e)
    raise
# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def handle_request_get(sockobj, thiscommhandle):
  htmlresponse = generate_html_page("")
  sockobj.send(make_http_ok_response(htmlresponse))
  stopcomm(thiscommhandle)

def sendChanges(msg):
  # Stupid hack for local testing
  msg += "BOARD_UPDATE" + msg
  remotePort = 63101
  if mycontext['port'] == 63101:
    remotePort = 63100
  socketobject = openconn('127.0.0.1', remotePort)
  socketobject.send(msg)
  socketobject.close()

# ------------------------------------------------------------------------------
# Handles POST \Add request from browser
# ------------------------------------------------------------------------------
def handle_request_add(msgheader, sockobj, thiscommhandle):
  # Increment logical clock
  mycontext['ts'] = mycontext['ts'] + 1

  # Get comment from message
  message = msgheader.split('comment=')[1]

  # Add to local list of client-side changes
  changeEntry = addToChangesList(message, 'add')
  print mycontext['changes']

  # Update HTML
  handle_request_get(sockobj, thiscommhandle)

  convertToDict(mycontext['changes'])
  #print mycontext['boardMessages']

  sendChanges(formatChangesString())

def handle_update(msgheader, sockobj, thiscommhandle):
  msg = msgheader.split('BOARD_UPDATE')[1]
  remoteChanges = disassembleChangesString(msg)
  mycontext['changes'] = mergeChanges(remoteChanges, mycontext['changes'])
  print 'Combined changes:', mycontext['changes']

  convertToDict(mycontext['changes'])

  #print mycontext['boardMessages']

  # Update HTML
  handle_request_get(sockobj, thiscommhandle)

# ------------------------------------------------------------------------------
# Handles POST /Change request from browser
# ------------------------------------------------------------------------------
def handle_request_change(msgheader, sockobj, thiscommhandle):
  print "Received POST /Change"

  # Get comment from message
  message = msgheader.split('comment=')[1]

  # Add to local list of client-side changes
  changeEntry = addToChangesList(message, 'remove')
  print mycontext['changes']

  convertToDict(mycontext['changes'])
  print mycontext['boardMessages']

  # Update HTML
  handle_request_get(sockobj, thiscommhandle)

  sendChanges(formatChangesString())

# Adds an entry to the list of changes and returns the added entry
def addToChangesList(message, operation):
  if operation == 'remove':
    # Get timestamp value from remove message
    ts = message.split('&')[1].split('=')[1]
  else:
    ts = mycontext['ts']

  ipOrPort = mycontext['port'] # Port if local, IP if remote

  entry = (operation, str(ts), str(ipOrPort), message)
  mycontext['changes'].append(list(entry))

  return entry

# Formats the list of changes into a string to be sent as message
def formatChangesString():
  changesList = mycontext['changes']

  # entry = [operation, ts, ipOrPort, message]
  # Example: add,1,63100,testing123|remove,1,63101,testing123
  changesString = ''
  for entry in changesList:
    changesString += entry[0] + ',' + str(entry[1]) + ',' + str(entry[2]) + ',' + entry[3] + '|'

  return changesString

# Converts formatted message string back to a list
def disassembleChangesString(changesString):
  changesList = []

  for entry in changesString.split('|'):
    formattedEntry = []
    if entry == '':
      continue
    index = 0 
    for attribute in entry.split(','):
      if index == 1:
        if attribute > mycontext['ts']:
          print "found higher timestamp", attribute
          mycontext['ts'] = attribute

      formattedEntry.append(attribute)
      index++
    changesList.append(formattedEntry)

  return changesList

# Combines two lists of changes into one, removing duplicates
def mergeChanges(list1, list2):
  combinedList = list1
  combinedList.extend([entry for entry in list2 if entry not in combinedList])

  return combinedList

# Converts a list of changes to a dict
def convertToDict(changesList):
  # [['add', '1', '63100', 'test'], ['add', '2', '63100', 'test2']]
  OP = 0
  SEQ = 1
  PORT = 2
  MSG = 3

  # Start a fresh board
  board = {}

  for entry in changesList:
    seqNr = int(entry[SEQ])
    port = int(entry[PORT])
    message = entry[MSG]
    operation = entry[OP]

    if operation == 'add':
      if seqNr in board:
        board[seqNr].append((port, message))
      else:
        board[seqNr] = [(port, message)]

    elif operation == 'remove':
      if len(board[seqNr]) == 1:
        del board[seqNr]
      else:
        index = 0
        for entry in board[seqNr]:
          if entry[PORT] == port:
            board[seqNr].pop(index)
            break
          index += 1

  mycontext['boardMessages'] = board

# ------------------------------------------------------------------------------
# Wrap into HTTP headers
# ------------------------------------------------------------------------------
def make_http_ok_response(htmlresponse):
    return "HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
    "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse)

# ------------------------------------------------------------------------------
# Utility function to extract the contents (payload) from HTTP request
# ------------------------------------------------------------------------------
def extract_http_request_contents(header):
  # find content length
  conent_length = header.split('Content-Length: ')[1]
  conent_length = int(conent_length.split('\r\n')[0])

  # extract the http response body and discard the header
  contetns = header[-conent_length:]
  return contetns

# ------------------------------------------------------------------------------
# Utility function to extract query parameter from HTML query
# ------------------------------------------------------------------------------
def extract_parameters_from_query(msg):
  # extract the query parameters as a dictionary: {name:value}
  # example input format: [operation, ts, ipOrPort, comment]

  #print 'MSG:', msg

  parameters={}
  parameters['comment'] = msg[3]
  parameters['src_ts'] = msg[1]
  parameters['src_ip'] = msg[2]

  return parameters

# ------------------------------------------------------------------------------
# Utility function to wrap an entry with HTML form markup
# ------------------------------------------------------------------------------
def entry_to_html(entry):
  if len(entry) > 0:
    # extract the query parameters
    parameters = extract_parameters_from_query(entry)
    comment = parameters['comment']
    #action = parameters['action']
    src_ts = int(parameters['src_ts'])
    src_ip = parameters['src_ip']
    #src_port = int(parameters['src_port'])

    #if action == 'Add':
    return '''<form class="entry" method="post" action="Change" >
                <input type="text" name="comment" value="%s" size="50"/>
                <input type="text" name="ts" value="%u" />
                <input type="text" name="ip" value="%s" />
                <input type="hidden" name="port" value="%u" />
                <input type="submit" name="action" value="Modify" />
                <input type="submit" name="action" value="Delete" />
              </form>''' %(comment, src_ts, src_ip, 1337)
  return ""

# ------------------------------------------------------------------------------
# Outputs the blackboard html
# Optional parameter: status.
# ------------------------------------------------------------------------------
def generate_html_page(status=""):
  #Initialize blackboard content

  # dynamic title showing Ip address, port and up time.
  board_title = '<div id="boardtitle_placeholder" class="boardtitle">Board contents at host: %s:%u, up time: %u sec.</div>' %(mycontext['ip'], mycontext['port'], int(getruntime()))
  # An optional status message
  status_message = "<div class='status'>%s</div>" % (status)

  # convert entries to html
  # TODO: Must get entries from board dict instead of changes!
  entries = [entry_to_html(e) for e in mycontext['changes']]
  entries = "".join(entries)

  # merging the contents of the board with the title
  # and wrapping all with <div id="boardcontents_placeholderâ€>...</div>
  content = [mycontext['headerhtml'], '<div id="boardcontents_placeholder">', board_title, status_message, entries, '</div>', mycontext['footerhtml']]

  #Concatenate strings into huge string representing the final html
  content = "".join(content)
  del entries
  return content

# ------------------------------------------------------------------------------
# Main entry point of the program. Initalizes global variables in mycontext
# and calls start_board() which opens the socket for incoming connections.
# ------------------------------------------------------------------------------
if callfunc == 'initialize':
  # Running remotely (assuming that we pass one input argument only when we run remotely):
  # whenever this vessel gets a connection on its IPaddress:Clearinghouseport it'll call function board
  if len(callargs) == 1:
    port = int(callargs[0])
    ip = getmyip()

    vesselIPs = []
    ipList = open('iplist.txt', 'r')
    for ipaddr in ipList:
      vesselIPs.append(ipaddr.rstrip())

    mycontext['iplist'] = vesselIPs
    ipList.close()

  # To run locally: use the loopback ip address (127.0.0.1) and a port in the range 63100 .. 63110
  # If you start multiple local instances using different ports, you can debug and test your code locally
  # example:
  # python ../demokit/repy.py ../demokit/restrictions.default skeleton2015advanced.repy 127.0.0.1 63100
  elif len(callargs) == 2:
    port = int(callargs[1])
    ip = callargs[0]

  # Fail if we don't have 1 or 2 arguments
  else:
    raise Exception("Specify a port only for auto detection of IP, or specify IP and port")

  #GLOBAL Variables go to mycontext

  #logical clock\timestamp
  mycontext['ts'] = 0

  #Initialize Port and IP
  mycontext['port'] = port
  mycontext['ip'] = ip

  #read header and footer html files
  mycontext['headerhtml'] = file("header.html").read()
  mycontext['footerhtml'] = file("footer.html").read()

  mycontext['changes'] = []
  mycontext['boardMessages'] = {}

  start_board()
